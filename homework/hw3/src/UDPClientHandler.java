import java.io.IOException;
import java.io.PrintWriter;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.util.*;

public class UDPClientHandler extends Thread{
    DatagramSocket client;
    InetAddress address;
    int port;
    LinkedHashMap<String, Integer> inventory;
    HashMap<String, List<Loan>> users;
    int[] nextId;

    public UDPClientHandler(DatagramSocket client, InetAddress address, int port, LinkedHashMap<String, Integer> inventory, HashMap<String, List<Loan>> users, int[] nextId){
        this.client = client;
        this.address = address;
        this.port = port;
        this.inventory = inventory;
        this.users = users;
        this.nextId = nextId;
    }

    // sets the protocol for communication with the server. The protocol is specified
    // by the letter parameter u or t where u sets the communication mode to UDP, and t sets the
    // communication mode to TCP. The default mode of communication is UDP. The server responds
    // with the message:‘The communication mode is set to TCP’ or ‘The communication mode is set
    // to UDP’.
    public void setMode(String mode) throws IOException {
        String outputMessage;
        if(mode.equals("t")){
            outputMessage = "The communication mode is set to TCP";
            client.close();
        }
        else{
            outputMessage = "The communication mode is set to UDP";
        }
        byte[] buffer = outputMessage.getBytes();
        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, port);
        client.send(packet);
    }

    // inputs the name of a user and book. The client
    // sends this command to the server using the communication protocol given by the current mode.
    // If the library has all the copies of this book lent out, the server responds with the message:
    // ‘Request Failed - Book not available’. If the library does not have the book, the server responds
    // with message: ‘Request Failed - We do not have this book’. Otherwise, the borrow request
    // succeeds and the server replies with a message: ‘Your request has been approved, <loan-id>
    // <user-name> <book-name>’. The output parameter <loan-id> is a unique identifier to the
    // loan generated by the server each time a book is borrowed. A sensible approach is to have the
    // server assign the first loan an identifier of ‘1’ and increment each time a loan is completed. The
    // server should also update the library’s inventory of available books.
    public void beginLoan(String username, String bookname) throws IOException{
        String outputMessage;
        if(!inventory.containsKey(bookname))
            outputMessage = "Request Failed - We do not have this book";
        else if(inventory.get(bookname) == 0)
            outputMessage = "Request Failed - Book not available";
        else{
            inventory.put(bookname, inventory.get(bookname) - 1);
            if(!users.containsKey(username)){
                List<Loan> loans = new ArrayList<>();
                loans.add(new Loan(bookname, nextId[0]));
                users.put(username, loans);
            }
            else
                users.get(username).add(new Loan(bookname, nextId[0]));
            outputMessage = "Your request has been approved, " + nextId[0] + " " + username + " " + bookname;
            nextId[0]++;
        }
        byte[] buffer = outputMessage.getBytes();
        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, port);
        client.send(packet);
    }

    // return the book associated with the loan identified by <loan-id>. If
    // there is no existing loan with the id, the response is: ‘<loan-id> not found, no such borrow
    // record’. Otherwise, the server replies: ‘<loan-id> is returned’ and updates the inventory.
    public void end_loan(int loan_id) throws IOException{
        String outputMessage;
        boolean found = false;
        for(List<Loan> ll : users.values()){
            for(Loan l : ll){
                if(l.id == loan_id) {
                    ll.remove(l);
                    inventory.put(l.name, inventory.get(l.name) + 1);
                    found = true;
                    break;
                }
            }
            if(found)
                break;
        }
        if(found)
            outputMessage = "" + loan_id + " is returned";
        else
            outputMessage = "" + loan_id + " not found, no such borrow record";
        byte[] buffer = outputMessage.getBytes();
        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, port);
        client.send(packet);
    }

    // list all active loans associate with a user. If no loans are found for
    // the user, the system responds with the message: ‘No record found for <user-name>’. Otherwise,
    // list all records of active loans for the user as <loan-id> <book-name>. Note that, you should
    // print one line per loan record.
    public void get_loans(String username) throws IOException{
        List<Loan> ll = users.get(username);
        boolean found = (ll.size() != 0);
        if(found){
            String outputMessage = "";
            for(Loan l : ll)
                outputMessage += "" + l.id + " " + l.name + "\n";
            outputMessage += "DONE";
            byte[] buffer = outputMessage.getBytes();
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, port);
            client.send(packet);
        }
        else{
            String outputMessage = "No record found for " + username;
            byte[] buffer = outputMessage.getBytes();
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, port);
            client.send(packet);
        }
    }

    // lists all available books in the library. For each book, you should show
    // ‘<book-name> <quantity>’. Note that, even if there is no copies left, you should print the book
    // with quantity 0. In addition, you should print one line per book.
    public void get_inventory() throws IOException{
        String inventoryStr = "";
        for(Map.Entry<String, Integer> entry : inventory.entrySet()) {
            inventoryStr += entry.getKey() + " " + entry.getValue() + "\n";
        }
        byte[] data = inventoryStr.getBytes();
        DatagramPacket packet = new DatagramPacket(data, data.length, address, port);
        client.send(packet);
    }

    // inform server to stop processing commands from this client and print inventory to
    // inventory file named as “inventory.txt.” If there is an existing file with that name then that file
    // is overwritten.
    public void exit() throws IOException {
        String message = "exit";
        byte[] data = message.getBytes();
        DatagramPacket packet = new DatagramPacket(data, data.length, address, port);
        client.send(packet);
        PrintWriter pw = new PrintWriter("inventory.txt", "UTF-8");
        for(Map.Entry<String, Integer> entry : inventory.entrySet())
            pw.println(entry.getKey() + " " + entry.getValue());
        pw.close();
        client.close();
    }

    public void run(){
        
    }
}
